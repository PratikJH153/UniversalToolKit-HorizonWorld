'use strict';
const thrift = require('thrift');
const uuidv4 = require('uuid/v4');
const EventEmitter = require('events');

const ZERO = 0;
const EmptyPoolError = (serviceName) => new Error(`Pool of service ${serviceName} is empty`);

/**
 * @class A simple pool to group Thrift connections to services
 */
class ThriftClientPool extends EventEmitter {

	/**
	 * Just assigns default options
	 * @param  {Function} service A Thrift generated service
	 * @param  {Object} options Object with pool options:
	 *                          * scaleSize: an integer greater than 0 that will be used to scale
	 *                          connections to services in the same host
	 */
	constructor (service, options = {}) {

		super();

		this._service = service;
		this._addresses = new Set();
		this._options = Object.assign(
			{
				scaleSize:2,
				transport:thrift.TFramedTransport,
				protocol:thrift.TJSONProtocol
			},
			options
		);
		this._destroyed = false;

		this._pairs = new Map();
		this._pairsIterator = this._pairs.values();

	}

	/**
	 * Removes a connection by generated UUID
	 * @param  {string} uuid Connection UUID
	 * @return {this}
	 */
	_removeFromPool (uuid) {

		if (this._pairs.has(uuid)) {

			const {remoteAddress, remotePort} = this._pairs.get(uuid);

			this._pairs.delete(uuid);

			// Emit scale down event
			this.emit('scaleDown', remoteAddress, remotePort);

			// If there's no more connections, emits empty event
			if (this._pairs.size === ZERO)
				this.emit('empty');

		}

		return this;

	}

	/**
	 * Create a service connection to specified host and port
	 * @param  {string} host Server host (hostname, IPv4 or IPv6)
	 * @param  {integer} port The port to connect
	 */
	_connect (host, port) {

		try {
			let connection;

			if (this._options.secure) {
				connection = thrift.createSSLConnection(
					host,
					port,
					this._options
				);
			} else {
				connection = thrift.createConnection(
					host,
					port,
					this._options
				);
			}

			connection.on('error', (error) => this.emit('error', error));

			connection.on('close', () => {
				this._removeFromPool(connection.uuid);
			});

			// Scale up only when connected to server
			connection.on('connect', () => this.emit('scaleUp', host, port));

			connection.uuid = uuidv4();
			connection.remoteAddress = host;
			connection.remotePort = port;

			const client = thrift.createClient(this._service, connection);

			this._pairs.set(connection.uuid, [connection, client]);
		} catch (error) {
			this.emit('error', error);
		}

	}

	/**
	 * Returns information about pool
	 * @return {Object} An Object with information about pool
	 */
	information () {

		return {
			size:this._pairs.size,
			options:this._options,
			destroyed:this._destroyed,
			service:this._service.serviceName,
			connections:Array.from(this._pairs.keys()).map((uuid) => {

				const [connection] = this._pairs.get(uuid);

				return {
					uuid,
					address:connection.remoteAddress,
					port:connection.remotePort,
					connected:connection.connected
				};
			})
		};

	}

	/**
	 * Acquire a client from pool
	 * @param  {Boolean} _retry This argument is used only to avoid two interations to try to
	 *                          acquire a connection from pool, shouldn't be used by external classes
	 * @return {Function}         A Thrift client instance
	 */
	client (_retry = false) {

		// If pool is empty, throws an error
		if (this._pairs.size === ZERO)
			throw EmptyPoolError(this._service.serviceName);

		const pair = this._pairsIterator.next().value;

		if (!pair) {

			if (_retry)
				throw EmptyPoolError(this._service.serviceName);

			this._pairsIterator = this._pairs.values();

			return this.client(true);
		}

		const [,client] = pair;

		return client;

	}

	/**
	 * Scale connections to host and port
	 * @param  {string} host Server host (hostname, IPv4 or IPv6)
	 * @param  {integer} port The port to connect
	 * @return {this}
	 */
	scale (host, port) {

		const address = [host, port].join(',');

		if (this._addresses.has(address))
			throw new Error(`The service "${this._service.serviceName}" already has a pool to address: ${address}`);

		this._addresses.add(address);

		for (let x = 0; x < this._options.scaleSize; x++)
			this._connect(host, port);

		return this;

	}

	/**
	 * Destroys all connections of pool
	 * @return {this}
	 */
	destroy () {

		if (this._destroyed)
			return this;

		this._destroyed = true;

		for (const [,pair] of this._pairs) {
			const [connection] = pair;
			connection.destroy();
		}

		return this;

	}

}

module.exports = ThriftClientPool;