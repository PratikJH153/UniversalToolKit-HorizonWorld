'use strict';
const thrift = require('thrift');
const Promise = require('bluebird');
const request = require('request');
const Helpers = require('./helpers.js');
const path = require('path');
const fs = require('fs');
const fse = require('fs-extra');
const child_process = require('child_process');
const EventEmitter = require('events');
const ForwardEvents = require('./forward-events.js');
const ThriftClientPool = require('./thrift-client-pool.class.js');
const Database = require('./database.class.js');
const Service = require('./service.class.js');
const glob = require('glob');
const Ajv = require('ajv');

const mkdir = Promise.promisify(fs.mkdir);
const MINIMUM_INVALID_STATUS_CODE = 300;

/**
 * @class Main Horizon class
 */
class Horizon extends EventEmitter {

	/**
	 * Just assigns default values to optons and attributes
	 * @param  {Object} options An object with options to horizon:
	 *                          * resourcesPath: a string pointing to where Horizon will store resources
	 */
	constructor ({resourcesPath} = {}) {

		super();

		this._resourceProviders = [];

		this._resourcesPath = path.join(Helpers.mainPath, 'resources');
		this._thriftServices = {};
		this._thriftTypes = {};
		this._services = {};

		if (resourcesPath)
			this._resourcesPath = Helpers.makePathAbsolute(resourcesPath);

		// Default port to be used by services
		this._portCounter = 50000;
		this._clients = {};
		this._pools = {};
		this._databases = {};
		this._schemaValidator = new Ajv({
			format:'full',
			logger:false,
			removeAdditional:true
		});
		this._schemas = new Proxy(
			{},
			{
				get: (target, property) => {
					return (data) => this._schemaValidator.validate(property, data);
				}
			}
		);

		this._logger = {};

		ForwardEvents.fromLoggerToHorizon(this._logger, this);

	}

	/**
	 * Returns loaded Thrift types
	 */
	get Types () {
		return this._thriftTypes;
	}

	/**
	 * Returns loaded Thrift services
	 */
	get Services () {
		return this._thriftServices;
	}

	/**
	 * Returns connected services clients
	 */
	get Clients () {
		return this._clients;
	}

	/**
	 * Returns databases instances
	 */
	get Databases () {
		return this._databases;
	}

	/**
	 * Returns loaded schemas
	 */
	get Schemas () {
		return this._schemas;
	}

	/**
	 * Returns Logger
	 */
	get Logger () {
		return this._logger;
	}

	/**
	 * Returns information about Horizon instance
	 * @return {Object} An Object with Horizon informations
	 */
	information () {

		const information = {
			services:{},
			pools:{}
		};

		Object.keys(this._services).forEach((serviceName) => {

			const service = this._services[serviceName];

			information.services[serviceName] = {
				server:service.server.address()
			};

		});

		Object.keys(this._pools).forEach((serviceName) => {
			information.pools[serviceName] = this._pools[serviceName].information();
		});

		return information;

	}

	/**
	 * Adds resources providers
	 * @param {Object} resourceProvider An Object with specifications about resource providers
	 *                                  * url|directory: An string with url or directory where the resources are
	 *                                  * files: An Array of strings with files names inside the directory or url
	 *                                  that horizon will bring to service as resources
	 */
	addResourceProvider (resourceProvider) {

		const {directory, url, files} = resourceProvider;

		if (!directory && !url)
			throw new Error('Resources provider must have an url or a directory');

		if (!Array.isArray(files))
			throw new Error('Resources providers must have a files array with file names');

		this._resourceProviders.push(resourceProvider);

		return this;

	}

	/**
	 * Builds the resources path structure
	 * @return {Promise} A Promise rejecting only if an error on path creation occurred
	 */
	_buildResourcesPath () {

		return Promise.map(
			[
				this._resourcesPath
			].concat(
				[
					'schemas',
					'database',
					'javascript',
					'thrift'
				].map((item) => path.join(this._resourcesPath, item))
			),
			(directory) => {
				return mkdir(directory, {mode:'0760'}).catch((error) => {

					if (error.code !== 'EEXIST')
						return Promise.reject(error);

					return Promise.resolve();

				});
			},
			{concurrency:1}
		);

	}

	/**
	 * Acquires resources from resources providers
	 * @return {Promise} A Promise rejecting only if an error occurred while downloading resources
	 */
	acquireResources () {

		return this._buildResourcesPath().then(() => {

			return Promise.map(
				this._resourceProviders,
				({url,directory,files}) => {

					return Promise.map(
						files,
						(file) => {

							if (url)
								return this._acquireResourcesFromUrl(url, file);
							else if (directory)
								return this._acquireResourcesFromPath(directory, file);
							else
								return Promise.reject(new Error('Invalid resource type (url or directory not provided)'));

						}
					);

				}
			).then(() => {

				return this;

			});

		});

	}

	/**
	 * Defines the target path of a resource file based on file's name
	 * @param  {string} file File name
	 * @return {string}      Absolute target path of file
	 */
	_getTargetResourcePathFromFileName (file) {

		let targetPath;

		if (/\.database\./.test(file))
			targetPath = 'database';
		else if (/\.schema\.json$/.test(file))
			targetPath = 'schemas';
		else if (/\.js$/.test(file))
			targetPath = 'javascript';
		else if (/\.thrift$/.test(file))
			targetPath = 'thrift';
		else
			throw new Error(`Invalid file type: ${file}`);

		return path.join(this._resourcesPath, targetPath, file);

	}

	/**
	 * Acquires resources from url's downloading them
	 * @param  {string} url  URL to download the file from
	 * @param  {string} file The file name in the server
	 * @return {Promise}      A Promise rejecting only if an error occurred while downloading file
	 */
	_acquireResourcesFromUrl (url, file) {

		return new Promise((resolve, reject) => {

			const fileUrl = url.replace(/[/]*$/, '')+'/'+file;
			const resourceRequest = request(fileUrl);

			resourceRequest.on('error', (error) => reject(error));

			resourceRequest.on('response', (response) => {

				if (response.statusCode >= MINIMUM_INVALID_STATUS_CODE)
					return reject(new Error(`File download failed (url:${fileUrl}/statusCode:${response.statusCode})`));

				try {

					const targetPath = this._getTargetResourcePathFromFileName(file);

					fse.ensureDirSync(path.dirname(targetPath));

					const writeStream = fs.createWriteStream(targetPath);

					writeStream.on('error', (error) => reject(error));

					writeStream.on('finish', () => resolve());

					response.pipe(writeStream);

				} catch (error) {
					reject(error);
				}

			});

		});

	}

	/**
	 * Acquires resources from directory
	 * @param  {string} directory The directory to copy resources from
	 * @param  {string} file      File's name inside the directory
	 * @return {Promise}           A Promise rejecting only if an error occurred while copying the file
	 */
	_acquireResourcesFromPath (directory, file) {

		return new Promise((resolve, reject) => {

			directory = Helpers.makePathAbsolute(directory);

			const sourcePath = path.join(directory, file);
			const targetPath = this._getTargetResourcePathFromFileName(file);

			fse.ensureDir(path.dirname(targetPath)).then(() => {

				if (sourcePath === targetPath)
					return resolve();

				const readStream = fs.createReadStream(sourcePath);

				readStream.on('error', (error) => reject(error));

				const writeStream = fs.createWriteStream(targetPath);

				writeStream.on('error', (error) => reject(error));

				writeStream.on('finish', () => resolve());

				readStream.pipe(writeStream);

			}).catch(error => reject(error));

		});

	}

	/**
	 * Compiles and loads Thrift files previous acquired from resources providers
	 * @param {boolean} generateFiles Generate thrift files
	 * @return {Promise} A Promise rejecting only if an error occurred while compiling the files
	 */
	compileThrift (generateFiles = true) {

		try {

			const thriftPath = path.join(this._resourcesPath, 'thrift');
			const thriftGenPath = path.join(thriftPath, 'gen-nodejs');

			if (generateFiles) {

				child_process.execSync(
					'for i in `find ./ -type f -name "*.thrift"`; do thrift -r --gen js:node $i; done',
					{
						cwd:thriftPath
					}
				);

			}

			const thriftFiles = fs.readdirSync(thriftGenPath);

			for (const thriftFile of thriftFiles) {

				if (/_types\.js$/.test(thriftFile)) {
					this._thriftTypes = Object.assign(
						this._thriftTypes,
						require(
							path.join(thriftGenPath, thriftFile)
						)
					);
					continue;
				}

				const serviceName = thriftFile.replace(/\.js$/, '');

				this._thriftServices[serviceName] = require(
					path.join(thriftGenPath, thriftFile)
				);

				this._thriftServices[serviceName].serviceName = serviceName;

			}

			return Promise.resolve();

		} catch (error) {
			return Promise.reject(error);
		}

	}

	/**
	 * Connect databases
	 * @param  {Database} databaseConstructor Classes implementing databases connections extending
	 *                                        the abstract Database class.
	 * @param  {Object} options             Options to be passed to the database constructor
	 * @return {Promise}                     A Promise rejecting only if the connection with database fails
	 */
	connectDatabase (databaseConstructor, options = {}) {

		if (!(databaseConstructor.prototype instanceof Database))
			return Promise.reject(new Error('Databases must extend the abstract Horizon Database class'));

		let database;
		let databaseFiles = new Map();

		try {
			// Resources files are loaded from the value of the "databaseName" option as part of
			// resource file's name. An example for SQL databases:
			// If the databaseName in options is "postgres" files with names: my_table.postgres.database.sql
			// will be loaded. The .database suffix is required.
			const databasePath = path.join(this._resourcesPath, 'database');

			if (options.databaseName) {

				glob.sync(
					path.join(databasePath, `**/*${options.databaseName.toLowerCase()}.database*`),
					{
						absolute:true
					}
				).forEach((databaseFile) => {

					databaseFiles.set(
						path.basename(databaseFile),
						fs.readFileSync(databaseFile)
					);

				});

			}

			database = new databaseConstructor(databaseFiles, options);
		} catch (error) {
			return Promise.reject(error);
		}

		ForwardEvents.fromDatabaseToHorizon(database, this);

		return database.connect(this).then(({databaseName,databaseInstance}) => {
			this._databases[databaseName] = databaseInstance;
		});

	}

	/**
	 * Compiles JSON schemas using Ajv
	 * @return {Promise} A Promise rejecting only if an error occurred while loading the schema
	 */
	compileSchemas () {

		const schemasPath = path.join(this._resourcesPath, 'schemas');

		return new Promise((resolve, reject) => {

			glob(
				path.join(schemasPath, '**/*.schema.json'),
				{
					absolute:true
				},
				(error, files) => {

					if (error)
						return reject(error);

					try {

						for (const file of files) {

							const schema = require(file);

							schema['$async'] = true;

							this._schemaValidator.addSchema(schema);

						}

						resolve();

					} catch (error) {
						reject(error);
					}

				}
			);

		});

	}

	/**
	 * Provides a service, this service will be exposed when the .run() method is called
	 * @param  {Service} serviceConstructor A class extending the abstract Service class.
	 *                                      The class name mus be a name of Thrift service
	 *                                      loaded with compileThrift() method.
	 * @param  {Object} options            Options to provide the service:
	 *                                     * port: An integer to be used as service server port.
	 *                                     If it's not specified, Horizon will start serves incrementing
	 *                                     ports from the port 50000
	 * @return {Promise}                    A Promise rejecting only if an error occured while instantiating the service
	 */
	provideService (serviceConstructor, options = {}) {

		if (!(serviceConstructor.prototype instanceof Service))
			return Promise.reject(new Error('Services must extend the abstract Horizon Service class'));

		const serviceName = serviceConstructor.name;

		if (!Reflect.has(this._thriftServices, serviceName))
			return Promise.reject(new Error(`Unknown service "${serviceName}"`));

		try {

			// Injected resources
			serviceConstructor.Types = this._thriftTypes;
			serviceConstructor.Services = this._thriftServices;
			serviceConstructor.Clients = this._clients;
			serviceConstructor.Databases = this._databases;
			serviceConstructor.Schemas = this._schemas;
			serviceConstructor.Logger = this._logger;
			serviceConstructor.Horizon = this;

			const serviceInstance = new serviceConstructor();

			ForwardEvents.fromServiceToHorizon(serviceInstance, this);

			const port = options.port || this._portCounter++;

			const server = thrift.createServer(
				this._thriftServices[serviceName],
				serviceInstance.bindServiceMethods(),
				{
					transport:thrift.TFramedTransport,
					protocol:thrift.TJSONProtocol
				}
			);

			ForwardEvents.fromServerToHorizon(server, this);

			this._services[serviceName] = {
				serviceConstructor,
				serviceInstance,
				server,
				port
			};

			return Promise.resolve();

		} catch (error) {
			return Promise.reject(error);
		}

	}

	/**
	 * Connect to a service server, this method can be called multiple times to different hosts/ports (addresses)
	 * @param  {Function} service A Thrift service (can be accessed with horizon.Services after
	 *                            calling compileThrift)
	 * @param  {string} host    The host of the server
	 * @param  {string} port    The port of the server
	 * @param  {Object} options Options to be passed to ThriftClientPool constructor
	 * @return {Promise}         A Promise rejecting only if an error occured while connecting to server
	 */
	connectService (service, host, port, options = {}) {

		return new Promise((resolve, reject) => {

			let pool;
			const {serviceName} = service;

			if (!Reflect.has(this._pools, serviceName)) {

				pool = new ThriftClientPool(service, options);

				this._pools[serviceName] = pool;

				ForwardEvents.fromPoolToHorizon(pool, this);

			}

			pool = this._pools[serviceName];

			pool.once('error', reject).once('scaleUp', () => {

				pool.removeListener('error', reject);

				resolve();

			}).scale(host, port);

			this._clients[serviceName] = new Proxy(
				{},
				{
					get:(target, property) => {
						return (...args) => {
							return new Promise((resolve, reject) => {

								args.push((error, response) => {
									if (error)
										return reject(error);
									resolve(response);
								});

								try {
									pool.client()[property](...args);
								} catch (error) {
									reject(error);
								}

							});
						};

					}
				}
			);

		});

	}

	/**
	 * Disconnects from all services servers
	 * @return {Promise} A Promise rejecting only if an error occurred while disconnecting
	 */
	disconnectServices () {

		return Promise.map(
			Object.keys(this._pools),
			(serviceName) => {

				return this.disconnectService({serviceName});

			}
		);

	}

	/**
	 * Disconnects from specific service
	 * @param  {Service} serviceConstructor A class extending the abstract Service class.
	 *                                      The class name mus be a name of Thrift service
	 *                                      loaded with compileThrift() method.
	 * @return {Promise} A Promise rejecting only if an error occurred while disconnecting
	 */
	disconnectService ({serviceName}) {

		if (!Reflect.has(this._pools, serviceName))
			return Promise.reject(new Error(`No connected server found for service: ${serviceName}`));

		const pool = this._pools[serviceName];
		const information = pool.information();

		if (information.destroyed)
			return Promise.resolve();

		Reflect.deleteProperty(this._pools, serviceName);

		pool.destroy();

		return Promise.resolve();

	}

	/**
	 * Starts all service servers
	 * @return {Promise} A Promise rejecting only if an error occurred while starting the servers
	 */
	run () {

		return Promise.map(
			Object.keys(this._services),
			(serviceName) => {

				return new Promise((resolve, reject) => {

					try {

						const service = this._services[serviceName];

						service.server.once('listening', () => resolve());

						service.server.listen(service.port);

					} catch (error) {
						reject(error);
					}

				});

			}
		).then(() => {
			this.emit('online');
		});

	}

	/**
	 * Close all online service servers
	 * @return {Promise} A Promise rejecting only if an error occurred while closing servers
	 */
	close () {

		return Promise.map(
			Object.keys(this._services),
			(serviceName) => {

				return new Promise((resolve, reject) => {

					try {

						const service = this._services[serviceName];

						service.server.once('close', () => resolve());

						service.server.close();

					} catch (error) {
						reject(error);
					}

				});

			}
		).then(() => {
			this.emit('offline');
		});

	}

	/**
	 * Deletes resources folder, attention, this method is dangerous
	 * @return {Promise} A Promise rejecting only if an error occurred while deleting the folder
	 */
	clearResources () {

		try {

			Helpers.rmrfSync(this._resourcesPath);

			return Promise.resolve();

		} catch (error) {
			return Promise.reject(error);
		}

	}

}

module.exports = Horizon;