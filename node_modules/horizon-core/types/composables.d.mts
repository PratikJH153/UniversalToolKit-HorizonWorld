import type { Composable, CSS, H, Primitive, Props, Signal } from "../type.d.ts";
type StyleSignal = CSS.Style;
type StyleStringSignal = Signal.Signal<string, string>;
export declare const useStyle: <T extends CSS.Style | string>(object: T) => T extends string ? StyleStringSignal : StyleSignal;
export declare const useColorSheme: (config?: {
    get?: () => Composable.ColorSheme;
    set?: (v: Composable.ColorSheme) => void;
}) => Signal.Signal<Composable.ColorSheme, Composable.ColorSheme>;
export declare const useDebounceCallback: (watching: Props.OrSignal<any>[], delayMs: H.milliseconds, callback: () => unknown) => () => void;
export declare const useRandomInt: (a: H.int, b?: H.int) => number;
export declare const useRandomFloat: (a?: H.float, b?: H.float) => number;
export declare const useRandomString: (len?: H.int) => string;
export declare const useHistory: <State extends unknown>(config?: {
    length?: H.int;
    listen?: Signal.Signal<State>;
    keepName?: string;
}) => {
    readonly value: State[];
    push(state: State): never;
    undo(): State | undefined;
    redo(): State;
    clear(): void;
};
export declare const useFriction: (watchers: Props.OrSignal<unknown>[], config: {
    setup: (controller: AbortController) => unknown;
    abort?: () => void;
    debounce?: H.milliseconds;
    immediate?: boolean;
}) => void;
export declare const useTransport: <T extends Primitive.LikeProxy>(signalA: Signal.Signal<T>, signalB: Signal.Signal<T>) => {
    move(index: string | number): boolean;
    add(index: string | number): boolean;
    sub(index: string | number): boolean;
    toObject(config?: {
        aName?: string;
        bName?: string;
    }): {
        [x: string]: any;
    };
};
type AsyncSignalFunctionWrapper<T, A extends unknown[]> = (...args: A) => Promise<T> | T;
interface AsyncSignalFunction<T, A extends unknown[]> extends AsyncSignalFunctionWrapper<T, A> {
    process: Signal.Signal<boolean>;
}
export declare const useAsyncCallback: <T extends unknown, A extends unknown[]>(handle: (...args: A) => Promise<T> | T) => AsyncSignalFunction<T, A>;
interface ProcessConfig {
    at?: string | H.milliseconds;
    period?: H.milliseconds | string;
}
interface Process<T> extends Promise<T> {
    abort: () => void;
}
export declare const useProcess: (handle: (abort: () => void) => unknown, config?: ProcessConfig) => Process<void>;
type ParallelInfo<T> = T extends Function[] ? T : (T extends Record<string, () => any> ? {
    [K in keyof T]: Awaited<ReturnType<T[K]>>;
} : T);
export declare const useParallel: <T extends Record<string, () => any> | Function[]>(threads: T) => Promise<ParallelInfo<T>>;
export declare const useNormalizer: (data: Props.OrSignal<number[]>, config?: {
    chart?: boolean;
}) => Signal.Signal<{
    value: number;
    raw: number;
}[], number[]>;
interface Subscribe<T> {
    on(handle: (v: T) => void, key?: string): () => boolean;
    off(key: string): boolean;
    broadcast(v: T): void;
    clear(): void;
}
export declare const useSubscribe: <T extends unknown>() => Subscribe<T>;
interface EventMap<T extends Record<PropertyKey, unknown>> {
    on<K extends keyof T>(eventKey: K, handle: (v: T[K]) => void, key?: string): () => boolean;
    off(eventKey: keyof T, key: string): boolean;
    broadcast<K extends keyof T>(eventKey: K, v: T[K]): void;
    clear(eventKey?: keyof T): void;
}
export declare const useEventMap: <T extends Record<PropertyKey, unknown>>() => EventMap<T>;
export declare const useScrollLock: () => Signal.Signal<boolean, boolean>;
type TriggerSignal = Signal.Signal<boolean> & {
    trigger: () => void;
};
export declare const useTrigger: (handle: (push: Function) => void) => TriggerSignal;
export declare const useLocalStorage: <T extends unknown>(key: string, { defaultValue, safeValue }?: {
    defaultValue?: T;
    safeValue?: Signal.SignalConfig<T, T>["safeValue"];
}) => Signal.Signal<T, T>;
export declare const useSessionStorage: <T extends unknown>(key: string, { defaultValue }?: {
    defaultValue?: T;
}) => Signal.Signal<T, T>;
export declare const useDocumentHtml: (handle: (dom: HTMLHtmlElement) => void) => undefined;
export declare const useDocumentBody: (handle: (dom: HTMLBodyElement) => void) => undefined;
export declare const useGetDOM: <T extends HTMLElement>(selector: string, onFound: (dom: T) => void) => undefined;
export {};
